package code

import "testing"

// Generate bytecode instructions based on opcodes and their operands
func TestMake(t *testing.T) {
    tests := []struct {
        op          Opcode
        operands    []int
        expected    []byte
    }{
        // Takes OpConstant and operands and expect slice byte, holding three bytes
        {OpConstant, []int{65534}, []byte{byte(OpConstant), 255, 254}},
    }

    // Goes throught each test case in tests
    for _, tt := range tests {
        instruction := Make(tt.op, tt.operands...)

        // Compare the length of the generated bytecode with expected bytecode
        if len(instruction) != len(tt.expected) {
            t.Errorf("instruction has wrong length. want=%d, got=%d",
                len(tt.expected), len(instruction))
        }

        // Check if each byte in the generated instruction match the expected byte values
        for i, b := range tt.expected {
            if instruction[i] != tt.expected[i] {
                t.Errorf("wrong byte at pos %d. want=%d, got=%d",
                    i, b, instruction[i])
            }
        }
    }
}

func TestInstructionString(t *testing.T) {
    instructions := []Instructions {
        Make(OpConstant, 1),
        Make(OpConstant, 2),
        Make(OpConstant, 65535),
    }

    expected := `0000 OpConstant 1 0003 OpConstant 2 0006 OpConstant 65535`

    concatted := Instructions{}
    for _, ins := range instructions {
        concatted = append(concatted, ins...)
    }

    if concatted.String() != expected {
        t.Errorf("instructions wrongly formated.\nwant=%q\ngot=%q", expected, concatted.String())
    }
}
